// Generated by dts-bundle v0.7.3

declare module 'a-di' {
    import { Di } from 'a-di/Di';
    const di: Di;
    export = di;
}

declare module 'a-di/Di' {
    import { EntryCollection } from 'a-di/Entries/EntryCollection';
    import { MetaReader } from 'a-di/Entries/MetaReader';
    import { TypeEntry } from 'a-di/Entries/TypeEntry';
    import { FnEntry } from 'a-di/Entries/FnEntry';
    import { ObjectEntry } from 'a-di/Entries/ObjectEntry';
    import { IType } from 'a-di/Entries/IType';
    import { deco_for, deco_param } from 'a-di/deco';
    type OptionalConstructorParameters<T extends new (...args: any) => any> = T extends new (...args: infer P) => any ? Partial<P> : never;
    export class Di {
            parent: Di;
            /** Container for registered Types */
            entries: EntryCollection;
            /** Reader to get meta information from a Type */
            metaReader: MetaReader;
            /**
                * @param parent Optionaly pass the parent container
                */
            constructor(parent?: Di);
            /** Create new Di scope using current di as the parent container */
            new(): Di;
            /**
                * Create and register a Type: create mapping, aliases, etc
                * Example: `di.registerType(Foo).as(IFoo)`
                * @param Type
                * @returns TypeEntry to continue the registration flow
                */
            registerType(Type: IType): TypeEntry<any>;
            /**
                * Manually start registering a Type Factory
                * Example: `di.registerFactory(di => { return SomeInstance; }).as(IFoo)`
                * @param Type
                * @returns TypeEntry to continue the configuration flow
                */
            registerFactory(Fn: any): FnEntry<any>;
            /**
                * Creates a Type, same as `registerType` but doesn't register within this Di context
                */
            Type(Type: IType): TypeEntry;
            Factory<T extends Function>(fn: T): FnEntry<T>;
            Object(object: any): ObjectEntry;
            resolve<T extends new (...args: any[]) => any>(mix: string | T, ...args: OptionalConstructorParameters<T>): InstanceType<T>;
            wrapType<T>(Type: T): T;
            /** Alias for `inject`*/
            static param: typeof deco_param;
            /** Alias for `inject`*/
            param: typeof deco_param;
            static inject: typeof deco_param;
            inject: typeof deco_param;
            /**
                * Class Decorator to specify for which type is this implementation
                * ```
                * @di.for(AFoo)
                * class Foo {}
                * ```
                */
            for: typeof deco_for;
            /** Supports import { Di } from 'a-di' */
            static Di: typeof Di;
            /** Supports import { di } from 'a-di' */
            static di: Di;
            /** Supports import di from 'a-di' */
            static default: Di;
            /** Supports import di from 'a-di' */
            default: this;
            /** Supports import {  di } from 'a-di' */
            di: this;
    }
    export {};
}

declare module 'a-di/Entries/EntryCollection' {
    import { Entry } from 'a-di/Entries/Entry';
    import { TypeEntry } from 'a-di/Entries/TypeEntry';
    import { Di } from 'a-di/Di';
    import { IType } from 'a-di/Entries/IType';
    export class EntryCollection {
        protected arr: Entry[];
        protected ids: {
            [key: string]: Entry;
        };
        protected types: {};
        constructor(di: Di);
        add(entry: Entry): void;
        resolve<T>(mix: string | IType<T>, ...args: any[]): T;
        getByType<T>(Type: IType<T>): TypeEntry<T>;
        getFor(mix: any, required?: boolean): Entry;
        getForType(Type: any): Entry;
        removeForType(Type: any): void;
        removeFor(mix: any): void;
        removeAll(): void;
        registerFor(mix: any, entry: Entry): void;
    }
}

declare module 'a-di/Entries/MetaReader' {
    export class MetaReader {
        readFromType(Type: any): any;
    }
}

declare module 'a-di/Entries/TypeEntry' {
    import { BaseMethodEntry } from 'a-di/Entries/BaseMethodEntry';
    import { IType } from 'a-di/Entries/IType';
    import { Di } from 'a-di/Di';
    export class TypeEntry<T = any> extends BaseMethodEntry {
        Type: IType<T>;
        constructor(di: Di, Type: IType<T>);
        Entry(): IType<T>;
        resolve(...args: any[]): T;
        wrap<TOut = T>(): TOut;
    }
    export namespace Args {
        function getKey(args: any[], level?: number): string;
    }
}

declare module 'a-di/Entries/FnEntry' {
    import { BaseMethodEntry } from 'a-di/Entries/BaseMethodEntry';
    export class FnEntry<T extends Function> extends BaseMethodEntry {
        Fn: T;
        constructor(di: any, fn: T);
        Entry(): any;
        resolve(...args: any[]): any;
        wrap<TOut = T>(): TOut;
    }
}

declare module 'a-di/Entries/ObjectEntry' {
    import { Entry } from 'a-di/Entries/Entry';
    import { Di } from 'a-di/Di';
    export class ObjectEntry extends Entry {
        Object: any;
        resolvers: any[];
        constructor(di: Di, object: any);
        using(objectDefinitions: any): this;
        resolve(currentObject?: any): any;
        wrap(): any;
        Entry(): any;
    }
}

declare module 'a-di/Entries/IType' {
    export interface IType<T = any> {
        new (...args: any[]): T;
    }
}

declare module 'a-di/deco' {
    import { IType } from 'a-di/Entries/IType';
    interface IConstructorParam {
        Type?: IType;
        /** Type singleton will be based on such parameter values */
        singleton?: boolean;
    }
    export function deco_param(opts: IConstructorParam): any;
    export function deco_param(Type: IType | any): any;
    export function deco_for(Type: IType | any): any;
    export {};
}

declare module 'a-di/Entries/Entry' {
    import { Di } from 'a-di/Di';
    import { ITypeMeta } from 'a-di/TypeMeta';
    export abstract class Entry {
        di: Di;
        protected _as: any[];
        protected _using: any[];
        protected _params: any[];
        protected _resolvers: any[];
        protected _meta: ITypeMeta;
        cfg_arguments: string;
        cfg_singleton: boolean;
        onActivatedCb: any;
        constructor(di: Di);
        config(key: 'arguments', value: 'override' | 'ignore' | 'extend'): any;
        config(key: 'singleton', value: boolean | 'arguments'): any;
        using(...args: any[]): this;
        isSingleton(val?: boolean): this;
        for(...args: any[]): this;
        as(...args: any[]): this;
        register(): this;
        asSelf(): this;
        resolve(...args: any[]): any;
        onActivated(fn: any): void;
        Entry(): any;
        abstract wrap<T = any>(): T;
    }
}

declare module 'a-di/Entries/BaseMethodEntry' {
    import { Entry } from 'a-di/Entries/Entry';
    import { IType } from 'a-di/Entries/IType';
    import { Di } from 'a-di/Di';
    export abstract class BaseMethodEntry extends Entry {
        constructor(di: Di, Entry: Function | IType);
        withParams(...args: any[]): this;
        getParams_(...args: any[]): any[];
    }
}

declare module 'a-di/TypeMeta' {
    import { IType } from 'a-di/Entries/IType';
    export interface IConstructorParam {
        Type?: IType;
        /** Type singleton will be based on such parameter values */
        singleton?: boolean;
    }
    export interface ITypeMeta {
        params: IConstructorParam[];
        hasSingletonParams: boolean;
    }
    export namespace TypeMeta {
        function defineParam(Ctor: any, opts: IConstructorParam, index: number): void;
        function prepairMeta(Ctor: any): ITypeMeta;
    }
}

