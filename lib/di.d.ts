// Generated by dts-bundle v0.7.3

declare module 'di' {
    import { Di } from 'di/Di';
    const _default: Di;
    export = _default;
}

declare module 'di/Di' {
    import { EntryCollection } from 'di/Entries/EntryCollection';
    import { MetaReader } from 'di/Entries/MetaReader';
    import { TypeEntry } from 'di/Entries/TypeEntry';
    import { FnEntry } from 'di/Entries/FnEntry';
    import { ObjectEntry } from 'di/Entries/ObjectEntry';
    import { IType } from 'di/Entries/IType';
    export class Di {
        parent: Di;
        static Di: typeof Di;
        static di: Di;
        di: this;
        entries: EntryCollection;
        metaReader: MetaReader;
        constructor(parent?: Di);
        new(): Di;
        registerType(Type: IType): TypeEntry<any>;
        registerFactory(Fn: any): FnEntry<any>;
        Type(Type: IType): TypeEntry<any>;
        Function<T extends Function>(fn: T): FnEntry<T>;
        Object(object: any): ObjectEntry;
        resolve<T>(mix: string | IType<T>): T;
        wrapType(Type: any): any;
    }
}

declare module 'di/Entries/EntryCollection' {
    import { Entry } from 'di/Entries/Entry';
    import { TypeEntry } from 'di/Entries/TypeEntry';
    import { Di } from 'di/Di';
    import { IType } from 'di/Entries/IType';
    export class EntryCollection {
        protected arr: Entry[];
        protected ids: {};
        protected types: {};
        constructor(di: Di);
        add(entry: Entry): void;
        resolve<T>(mix: string | IType<T>): T;
        getByType<T>(Type: IType<T>): TypeEntry<T>;
        getFor(mix: any, required?: boolean): any;
        getForType(Type: any): Entry;
        removeForType(Type: any): void;
        removeFor(mix: any): void;
        registerFor(mix: any, entry: any): void;
    }
}

declare module 'di/Entries/MetaReader' {
    export class MetaReader {
        readFromType(Type: any): any;
    }
}

declare module 'di/Entries/TypeEntry' {
    import { BaseMethodEntry } from 'di/Entries/BaseMethodEntry';
    import { IType } from 'di/Entries/IType';
    import { Di } from 'di/Di';
    export class TypeEntry<T = any> extends BaseMethodEntry {
        Type: IType<T>;
        protected _singleton: T;
        constructor(di: Di, Type: IType);
        Entry(): IType<T>;
        resolve(...args: any[]): T;
        wrap(): (...args: any[]) => T;
    }
}

declare module 'di/Entries/FnEntry' {
    import { BaseMethodEntry } from 'di/Entries/BaseMethodEntry';
    export class FnEntry<T extends Function> extends BaseMethodEntry {
        Fn: T;
        constructor(di: any, fn: T);
        Entry(): any;
        resolve(...args: any[]): any;
        wrap(): T;
    }
}

declare module 'di/Entries/ObjectEntry' {
    import { Entry } from 'di/Entries/Entry';
    export class ObjectEntry extends Entry {
        container: any;
        Object: any;
        resolvers: any[];
        constructor(container: any, object: any);
        using(objectDefinitions: any): this;
        resolve(currentObject: any): any;
        wrap(): any;
        Entry(): any;
    }
}

declare module 'di/Entries/IType' {
    export interface IType<T = any> {
        new (...args: any[]): T;
    }
}

declare module 'di/Entries/Entry' {
    import { Di } from 'di/Di';
    import { IType } from 'di/Entries/IType';
    export abstract class Entry {
        di: Di;
        protected _as: any[];
        protected _using: any[];
        protected _params: any[];
        protected _resolvers: any[];
        cfg_arguments: string;
        cfg_singleton: boolean;
        onActivatedCb: any;
        constructor(di: Di);
        config(key: 'arguments', value: 'override' | 'ignore' | 'extend'): any;
        config(key: 'singleton', value: boolean): any;
        using(...args: any[]): this;
        isSingleton(val?: boolean): this;
        as(...args: any[]): this;
        register(): this;
        asSelf(): this;
        resolve(mix?: string | IType): any;
        onActivated(fn: any): void;
        Entry(): any;
    }
}

declare module 'di/Entries/BaseMethodEntry' {
    import { Entry } from 'di/Entries/Entry';
    import { IType } from 'di/Entries/IType';
    export class BaseMethodEntry extends Entry {
        constructor(di: any, Entry: Function | IType);
        withParams(...args: any[]): this;
        getParams_(...args: any[]): any[];
    }
}

