var Di = require('../src/Di');
var di = null;

class IFoo {}
class Foo {}
class Bar {
	constructor (foo) {
		this.foo = foo;
	} 
}
class Qux {
	constructor (options) {
		this.bar = options.bar;
		this.test = options.test;
	}	
}

UTest({
	'should test Types with dependencies in `using`': {
		$before () {
			di = new Di;
		},
		'should resolve dependency' () {		
			di
				.registerType(Foo)
				.as(IFoo);

			var foo = di.resolve(IFoo);
			is_(foo, Foo);
		},
		'should inject dependency' () {		
			di
				.registerType(Bar)
				.using(IFoo)
				.asSelf();

			var bar = di.resolve(Bar);
			is_(bar, Bar);
			is_(bar.foo, Foo);
		},
		'should inject dependencies into a method' () {
			var fn = di
				.Function(assert.await(function(foo, bar){
					is_(foo, Foo);
					is_(bar, Bar);
					is_(bar.foo, Foo);
				}))
				.using(IFoo, Bar)
				.wrap();

			fn();
		},
		'should inject arguments property' () {
			di
				.registerType(Qux)
				.using({ bar: Bar })
				.asSelf();

			var WrappedQux = di.wrapType(Qux);
			var qux = new WrappedQux({ test: 1});
			eq_(qux.test, 1);
			is_(qux.bar, Bar);
			is_(qux.bar.foo, Foo); 
		},
		'should instantiate not registered type' () {
			class Test {
				constructor (bar) {
					this.bar = bar;
				}
			}
			var test = di
				.Type(Test)
				.using(Bar)
				.resolve();

			is_(test.bar, Bar);
			is_(test.bar.foo, Foo);				
		},
		'should pre-define parameter' () {
			class Test {
				constructor (bar, myNumber) {
					this.bar = bar;
					this.num = myNumber;
				}
			}
			var entry = di
				.Type(Test)
				.using(Bar)
				.withParams(null, 10);
				
			var a = entry.resolve();
			is_(a.bar, Bar);
			eq_(a.num, 10);

			'> should override parameter'
			var b = entry.resolve(null, 11);
			is_(b.bar, Bar);
			eq_(b.num, 11);
		}
		
	},
	'should test Types with dependencies in meta declaration': {
		$before () {
			di = new Di;
		},
		
		'should inject dependency' () {
			class Foo {}
			class Bar {
				constructor (foo) {
					this.foo = foo;
				}
				static get $constructor() {
					return [Foo]
				}
			};
			di.registerType(Foo).asSelf();		
			di.registerType(Bar).asSelf();

			var bar = di.resolve(Bar);
			is_(bar, Bar);
			is_(bar.foo, Foo);
		},
		'should instantiate not registered type' () {
			class Qux {}
			class Test {
				constructor (qux) {
					this.qux = qux;
				}
				static get $constructor () {
					return [Qux];
				}
			}

			di.registerType(Qux).asSelf();

			var test = di
				.Type(Test)
				.resolve();

			is_(test.qux, Qux);			
		}
	}
})