import { EntryCollection } from './Entries/EntryCollection';
import { MetaReader } from './Entries/MetaReader';
import { TypeEntry } from './Entries/TypeEntry';
import { FnEntry } from './Entries/FnEntry';
import { ObjectEntry } from './Entries/ObjectEntry';
import { IType } from './Entries/IType';
import { deco_param } from './deco';
declare type OptionalConstructorParameters<T extends new (...args: any) => any> = T extends new (...args: infer P) => any ? Partial<P> : never;
export declare class Di {
    parent: Di;
    static Di: typeof Di;
    static di: Di;
    static default: Di;
    default: this;
    di: this;
    entries: EntryCollection;
    metaReader: MetaReader;
    constructor(parent?: Di);
    new(): Di;
    registerType(Type: IType): TypeEntry<any>;
    registerFactory(Fn: any): FnEntry<any>;
    Type(Type: IType): TypeEntry;
    Function<T extends Function>(fn: T): FnEntry<T>;
    Object(object: any): ObjectEntry;
    resolve<T extends new (...args: any[]) => any>(mix: string | T, ...args: OptionalConstructorParameters<T>): InstanceType<T>;
    wrapType<T>(Type: T): T;
    static param: typeof deco_param;
    param: typeof deco_param;
}
export {};
