// Generated by dts-bundle v0.7.3

declare module 'a-di' {
    import { Di } from 'a-di/Di';
    const di: Di;
    export = di;
}

declare module 'a-di/Di' {
    import { EntryCollection } from 'a-di/Entries/EntryCollection';
    import { MetaReader } from 'a-di/Entries/MetaReader';
    import { TypeEntry } from 'a-di/Entries/TypeEntry';
    import { FnEntry } from 'a-di/Entries/FnEntry';
    import { ObjectEntry } from 'a-di/Entries/ObjectEntry';
    import { IType } from 'a-di/Entries/IType';
    import { deco_param } from 'a-di/deco';
    type OptionalConstructorParameters<T extends new (...args: any) => any> = T extends new (...args: infer P) => any ? Partial<P> : never;
    export class Di {
        parent: Di;
        static Di: typeof Di;
        static di: Di;
        static default: Di;
        default: this;
        di: this;
        entries: EntryCollection;
        metaReader: MetaReader;
        constructor(parent?: Di);
        new(): Di;
        registerType(Type: IType): TypeEntry<any>;
        registerFactory(Fn: any): FnEntry<any>;
        Type(Type: IType): TypeEntry;
        Function<T extends Function>(fn: T): FnEntry<T>;
        Object(object: any): ObjectEntry;
        resolve<T extends new (...args: any[]) => any>(mix: string | T, ...args: OptionalConstructorParameters<T>): InstanceType<T>;
        wrapType<T>(Type: T): T;
        static param: typeof deco_param;
        param: typeof deco_param;
    }
    export {};
}

declare module 'a-di/Entries/EntryCollection' {
    import { Entry } from 'a-di/Entries/Entry';
    import { TypeEntry } from 'a-di/Entries/TypeEntry';
    import { Di } from 'a-di/Di';
    import { IType } from 'a-di/Entries/IType';
    export class EntryCollection {
        protected arr: Entry[];
        protected ids: {
            [key: string]: Entry;
        };
        protected types: {};
        constructor(di: Di);
        add(entry: Entry): void;
        resolve<T>(mix: string | IType<T>, ...args: any[]): T;
        getByType<T>(Type: IType<T>): TypeEntry<T>;
        getFor(mix: any, required?: boolean): Entry;
        getForType(Type: any): Entry;
        removeForType(Type: any): void;
        removeFor(mix: any): void;
        removeAll(): void;
        registerFor(mix: any, entry: Entry): void;
    }
}

declare module 'a-di/Entries/MetaReader' {
    export class MetaReader {
        readFromType(Type: any): any;
    }
}

declare module 'a-di/Entries/TypeEntry' {
    import { BaseMethodEntry } from 'a-di/Entries/BaseMethodEntry';
    import { IType } from 'a-di/Entries/IType';
    import { Di } from 'a-di/Di';
    export class TypeEntry<T = any> extends BaseMethodEntry {
        Type: IType<T>;
        constructor(di: Di, Type: IType<T>);
        Entry(): IType<T>;
        resolve(...args: any[]): T;
        wrap<TOut = T>(): TOut;
    }
    export namespace Args {
        function getKey(args: any[]): string;
    }
}

declare module 'a-di/Entries/FnEntry' {
    import { BaseMethodEntry } from 'a-di/Entries/BaseMethodEntry';
    export class FnEntry<T extends Function> extends BaseMethodEntry {
        Fn: T;
        constructor(di: any, fn: T);
        Entry(): any;
        resolve(...args: any[]): any;
        wrap<TOut = T>(): TOut;
    }
}

declare module 'a-di/Entries/ObjectEntry' {
    import { Entry } from 'a-di/Entries/Entry';
    import { Di } from 'a-di/Di';
    export class ObjectEntry extends Entry {
        Object: any;
        resolvers: any[];
        constructor(di: Di, object: any);
        using(objectDefinitions: any): this;
        resolve(currentObject?: any): any;
        wrap(): any;
        Entry(): any;
    }
}

declare module 'a-di/Entries/IType' {
    export interface IType<T = any> {
        new (...args: any[]): T;
    }
}

declare module 'a-di/deco' {
    import { IType } from 'a-di/Entries/IType';
    interface IConstructorParam {
        Type?: IType;
        /** Type singleton will be based on such parameter values */
        singleton?: boolean;
    }
    export function deco_param(opts: IConstructorParam): any;
    export function deco_param(Type: IType): any;
    export {};
}

declare module 'a-di/Entries/Entry' {
    import { Di } from 'a-di/Di';
    import { ITypeMeta } from 'a-di/TypeMeta';
    export abstract class Entry {
        di: Di;
        protected _as: any[];
        protected _using: any[];
        protected _params: any[];
        protected _resolvers: any[];
        protected _meta: ITypeMeta;
        cfg_arguments: string;
        cfg_singleton: boolean;
        onActivatedCb: any;
        constructor(di: Di);
        config(key: 'arguments', value: 'override' | 'ignore' | 'extend'): any;
        config(key: 'singleton', value: boolean | 'arguments'): any;
        using(...args: any[]): this;
        isSingleton(val?: boolean): this;
        as(...args: any[]): this;
        register(): this;
        asSelf(): this;
        resolve(...args: any[]): any;
        onActivated(fn: any): void;
        Entry(): any;
        abstract wrap<T = any>(): T;
    }
}

declare module 'a-di/Entries/BaseMethodEntry' {
    import { Entry } from 'a-di/Entries/Entry';
    import { IType } from 'a-di/Entries/IType';
    import { Di } from 'a-di/Di';
    export abstract class BaseMethodEntry extends Entry {
        constructor(di: Di, Entry: Function | IType);
        withParams(...args: any[]): this;
        getParams_(...args: any[]): any[];
    }
}

declare module 'a-di/TypeMeta' {
    import { IType } from 'a-di/Entries/IType';
    export interface IConstructorParam {
        Type?: IType;
        /** Type singleton will be based on such parameter values */
        singleton?: boolean;
    }
    export interface ITypeMeta {
        params: IConstructorParam[];
        hasSingletonParams: boolean;
    }
    export namespace TypeMeta {
        function defineParam(Ctor: any, opts: IConstructorParam, index: number): void;
        function prepairMeta(Ctor: any): ITypeMeta;
    }
}

